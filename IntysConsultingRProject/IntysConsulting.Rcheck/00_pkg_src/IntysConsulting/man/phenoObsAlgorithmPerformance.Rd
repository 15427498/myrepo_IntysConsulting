% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/phenoOBSAlgorithmAnalysis.R
\name{phenoObsAlgorithmPerformance}
\alias{phenoObsAlgorithmPerformance}
\title{Algorithm performances analysis of pheno OBS.}
\usage{
phenoObsAlgorithmPerformance(
  parentsPhenotypeDataFrame,
  offspringPhenotype,
  parentsGeneticSimilarityArray,
  geneticSimilarityWeight,
  penaltyReplicatedIndividuals,
  inclusionSet = NULL,
  solutionSize,
  maximumSearchTime = 60000,
  timeWithoutImprovement = 10000,
  maximumNumberMoves = 9e+07,
  numberSearches,
  numberRuns,
  searchIds = as.character(c(1:numberSearches)),
  searchMethod,
  analysisParametersMS = rep(NA, numberSearches),
  analysisParametersPT = matrix(NA, nrow = numberSearches, ncol = 3)
)
}
\arguments{
\item{parentsPhenotypeDataFrame}{(required) A data frame containing the parentNames in the first column, the trait names as headings in the remianing columns, and the parent phenotype information in the remaining matrix entries.
See example below for more clarity.
This data frame may also be obtained from the phenoOBSDataManagement output.}

\item{offspringPhenotype}{(required) A matrix containing:
* The feasible offspring Ids in the first column,
* The corresponding offspring parents in the second and third columns, and
* The weighted, normalised trait objective evaluation of the offspring.
This Matrix is obtained from the phenoOBSDataManagement output.}

\item{parentsGeneticSimilarityArray}{(required) An array containing the normalised upper triangular entries of the parents genetic similarity matrix.
This Matrix is obtained from the phenoOBSDataManagement output.}

\item{geneticSimilarityWeight}{(required) A value in the range [0,1] for the importance of solution similarity relative to the traits.
For example, if specified to be 0.3, then the algorithm will automatically allocate 0.7 toward finding solutions that are strong across the entirety of the traits sub-objective.
Note, however, that the individual trait importances are in phenoOBSDataManagement.}

\item{penaltyReplicatedIndividuals}{(default, double) A soft-constraint value penalising the presence of replicated individuals in a solution.
Note that this value is not normalised alongside the set of upper triangular matrix entries, and so it must have at least a value of one.}

\item{inclusionSet}{(default) An array containing the integer ids of offsping crosses that the user desires to observe in the returned solution.
The default value is a null vector, so that no id inclusion constraint is imposed on the selection of crosses.}

\item{solutionSize}{(required, integer) The number of crosses to be extracted.}

\item{maximumSearchTime}{(required, integer) The total duration of each search run.
This parameter is configured in milliseconds.}

\item{timeWithoutImprovement}{(default, integer) An upper bound on the total duration of the optimisation process.
This parameter is configured in milliseconds.}

\item{maximumNumberMoves}{(default, integer) An upper bound on the total number of search space solutions visited and assessed during the course of the optimisation process.
This parameter is configured in milliseconds.}

\item{numberSearches}{(required, integer) The total number of search method configurations probed in the analysis.}

\item{numberRuns}{(required, integer) The total number of algorithm runs performed for each search.}

\item{searchIds}{(default, String array) A [1*S] vector of strings used as identifyers for the various search method configurations.
The default argument consists of the string array ("1", "2", ... , "S").}

\item{searchMethod}{(required, string) Summon either one of these three proposed algorithms to analyse: 
1. Random descent (enter "RD"); 
2. Metropolis search (enter "MS") or 
3. Parallel  tempering (enter "PT").}

\item{analysisParametersMS}{(default, N.A.) A [1*S] vector specifying the initial temperatures of the Metropolis search algorithm.}

\item{analysisParametersPT}{(default, N.A.) A [S*3] data vector specifying the search parameters of the parallel tempering search algorithm.
In the first, second and third columns (respectively):
1. processors (integer) : The number of processors running in parallel.
2. minTemp (double) : Minimum (i.e. final) temperature.
3. maxTemp (double) : Maximum (i.e. initial) temperature.}
}
\value{
A list containing the following four objects (respectively): 
1. A 2D array containing the best found objective values for each run (columns dimension) and for each search (rows dimension),
2. A 3D array containing the best found solution ids (depth dimension) for each run (columns dimension) and for each search (rows dimension),
3. A 3D array containing the updated new best found solution objective values throughout the algorithm (depth dimension) for each run (columns dimension) and for each search (rows dimension), and
4. A 3D array containing the updated new best found solution objective times throughout the algorithm (depth dimension) for each run (columns dimension) and for each search (rows dimension).
Note: the last value across the depth dimension of this array in any given search and run therefore corresponds to the convergence time.
}
\description{
Run an analysis to investigate the parameter tuning sensitivity and convergence properties of the studied algorithms.
}
\details{
Symbols notation:
* S : The total number of searches in the analysed scenario.
* R : The total number of runs in each search.
* n : The size of the solution.
Assumptions: (any of these may be altered at a later stage if necessary, as per user request) 
1. This function operates for one problem at a time .
2. The number of runs is the same across all searches (this may be altered at a later stage, as per user request).
3. Each run is assigned the same termination criteria.
}
\examples{
parentsPhenotypeDataFrame <- data.frame(
parentNames = c("A","B","C","D"),
Yield = c(1200,1300,1250,1150),
Lint = c(50,40,45,55),
BollType = c(4.5,4,3,4.5))
offspringPhenotype <- matrix(nrow = 5, ncol = 4)
offspringPhenotype[1,] <- c(1,1,2,0.6)
offspringPhenotype[2,] <- c(2,1,3,0.5)
offspringPhenotype[3,] <- c(4,2,3,0.7)
offspringPhenotype[4,] <- c(5,2,4,0.5)
offspringPhenotype[5,] <- c(6,3,4,0.4)
parentsGeneticSimilarityArray <- c(1,0.33333333,0,0.66666667,0.166666667,0.8333333333)
geneticSimilarityWeight <- 0.4
penaltyReplicatedIndividuals <- 1.08
inclusionSet <- c(4)
solutionSize <- 2
maximumSearchTime <- 500
timeWithoutImprovement <- 200
maximumNumberMoves <- 400
numberSearches <- 2
numberRuns <- 2
searchIds <- c("Search 1","Search 2")
searchMethod <- "MS"
analysisParametersMS <- c(8,0.5) 
analysisParametersPT <- matrix(nrow=numberSearches, ncol=3)
analysisParametersPT[1,] <- c(5,0.1,6)
analysisParametersPT[2,] <- c(5,0.001,2)

}
\author{
A.Colmant and G.De Meyer
}
